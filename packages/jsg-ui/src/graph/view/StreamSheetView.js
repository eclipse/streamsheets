/********************************************************************************
 * Copyright (c) 2020 Cedalo AG
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0.
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 ********************************************************************************/
import {
	default as JSG,
	CellRange,
	TreeItemsNode,
	InboxContainer,
	OutboxContainer,
	StreamSheet,
	StreamSheetContainer,
	TextNode,
	StringExpression,
	SheetPlotNode,
	SheetCheckboxNode,
	SheetSliderNode,
	SheetKnobNode,
	Expression,
	NumberExpression,
	SheetCommandFactory,
	Point,
	BoundingBox,
	Shape,
	SetAttributeAtPathCommand,
} from '@cedalo/jsg-core';
import CellFeedbackView from '../feedback/CellFeedbackView';
import WorksheetView from './WorksheetView';
import ClientEvent from '../../ui/events/ClientEvent';
import ScrollBar from '../../ui/scrollview/ScrollBar';

const SHEET_DROP_FROM_OUTBOX = 'sheet_drop_from_outbox';

/**
 * This view is for a {{#crossLink "StreamSheet"}}{{/crossLink}} model. Although it
 * can be instantiated directly the recommended way to create this view is by calling
 * {{#crossLink "NodeController/createView:method"}}{{/crossLink}} method.
 *
 * @class StreamSheetView
 * @extends WorksheetView
 * @param {StreamSheet} item The corresponding StreamSheet model.
 * @constructor
 */
export default class StreamSheetView extends WorksheetView {
	// to allow scrolling while formula editing
	handleMouseEvent(ev, viewer) {
		const node = this.getItem();
		// content hidden -> ignore
		if (!node.isVisible()) {
			return;
		}

		this._scrollview.handleMouseEvent(ev);
		if (ev.isConsumed) {
			ev.keepFocus = true;

			node.getGraph().markDirty();
			if (viewer !== undefined && (node.getParent() instanceof StreamSheetContainer)) {
				this.getParent().moveSheetToTop(viewer);
			}
		}
	}

	getFeedback(location, startLocation, title, sourceView, key, event, viewer) {
		if (sourceView === undefined) {
			return undefined;
		}

		const bounds = this.getScrollView().getBounds();
		let point = new Point(0, 0);
		const hScrollSize =
			this.getItem().getHorizontalScrollbarMode() === JSG.ScrollBarMode.HIDDEN ? 0 : ScrollBar.SIZE;
		const vScrollSize = this.getItem().getVerticalScrollbarMode() === JSG.ScrollBarMode.HIDDEN ? 0 : ScrollBar.SIZE;

		point.setTo(location);
		point = this.translateToSheet(point, viewer);

		if (point.x > bounds.width - vScrollSize || point.y > bounds.height - hScrollSize) {
			return undefined;
		}

		const cell = this.getCell(point);
		if (cell === undefined || cell.x === -1 || cell.y === -1) {
			return undefined;
		}

		let range;
		let color = '#FFFFFF';
		let label = '';

		if (this.isMessageBox(sourceView, event)) {
			return undefined;
		}
		const inBox = this.isInbox(sourceView, event);
		if (inBox === undefined) {
			return undefined;
		}

		const selectedItem = sourceView.getSelectedItem();
		const vertical = event.isPressed(ClientEvent.KeyType.CTRL);
		const altKey = event.isPressed(ClientEvent.KeyType.ALT);

		const treeItems = sourceView.getItem().getSubTreeForItem(selectedItem);
		treeItems.unshift(selectedItem);

		let skipDepth;
		const rows = key ? treeItems.length : 1;
		let displayRows = 0;

		for (let i = 0; i < rows; i += 1) {
			if (skipDepth !== undefined && skipDepth === treeItems[i].depth) {
				while (treeItems[i] && treeItems[i].depth >= skipDepth) {
					i += 1;
					if (treeItems[i] === undefined) {
						break;
					}
				}
				if (i >= rows) {
					break;
				}
				skipDepth = undefined;
			}
			const itemPath = sourceView.getItem().getItemPath(treeItems[i]);
			const path = TreeItemsNode.splitPath(itemPath);
			const activeItem = sourceView
				.getItem()
				.getTreeItemAttributes()
				.getActiveElement()
				.getValue();
			let activePath;

			if (activeItem && activeItem.length && itemPath.startsWith(`${activeItem}`)) {
				activePath = TreeItemsNode.splitPath(activeItem);
			}

			let pos = inBox ? 1 : 0;

			if (inBox) {
				if (activePath && activePath.length !== path.length) {
					for (; pos < activePath.length; pos += 1) {
						if (activePath[pos] !== path[pos]) {
							break;
						}
					}
					if (pos === activePath.length) {
						pos += 1;
						if (skipDepth === undefined) {
							skipDepth = treeItems[i].depth;
						}
					} else {
						pos = 0;
					}
				} else {
					pos = 1;
				}
			}
			displayRows += 1;
		}

		if (altKey) {
			if (vertical) {
				range = new CellRange(this.getItem(), cell.x, cell.y - (key ? 1 : 0), cell.x + displayRows - 1, cell.y);
			} else {
				range = new CellRange(this.getItem(), cell.x - (key ? 1 : 0), cell.y, cell.x, cell.y + displayRows - 1);
			}
		} else if (vertical) {
			range = new CellRange(this.getItem(), cell.x, cell.y, cell.x + displayRows - 1, cell.y + (key ? 1 : 0));
		} else {
			range = new CellRange(this.getItem(), cell.x, cell.y, cell.x + (key ? 1 : 0), cell.y + displayRows - 1);
		}

		label = selectedItem.key;
		({ color } = selectedItem);

		const rect = this.getRangeRect(range);
		let cellPoint = this.translateFromSheet(new Point(rect.x, rect.y), viewer);
		const feedback = new CellFeedbackView(cell, label, !altKey || vertical, !altKey || !vertical);

		const box = new BoundingBox(rect.width, rect.height);
		box.setTopLeftTo(cellPoint);

		feedback._key = key;
		feedback.setBoundingBox(box);

		if (!altKey || vertical) {
			range._x2 = range._x1;
		} else {
			range._x1 = range._x2;
		}

		if (!altKey || !vertical) {
			range._y2 = range._y1;
		} else {
			range._y1 = range._y2;
		}
		const rectColor = this.getRangeRect(range);
		cellPoint = this.translateFromSheet(new Point(rectColor.x, rectColor.y), viewer);
		rectColor.x = cellPoint.x;
		rectColor.y = cellPoint.y;
		feedback.setColorRect(rectColor, color);

		return feedback;
	}

	isMessageBox(sourceView) {
		return (
			sourceView
				.getItem()
				.getParent()
				.getParent()
				.getType()
				.getValue() === 'ml'
		);
	}

	getSourceProcessSheet(sourceView) {
		const sourceParent = sourceView
			.getItem()
			.getParent()
			.getParent()
			.getParent();
		if (sourceParent) {
			return sourceParent.getStreamSheet();
		}

		return undefined;
	}

	isOutbox(sourceView) {
		return !!this.getOutbox(sourceView);
	}

	isInbox(sourceView, event) {
		const sourceParent = sourceView
			.getItem()
			.getParent()
			.getParent()
			.getParent();

		if (sourceParent instanceof InboxContainer) {
			return 1;
			// return event.event.altKey ? 0 : 1;
		}
		if (sourceParent instanceof OutboxContainer) {
			return 0;
		}

		return undefined;
	}

	getOutbox(sourceView) {
		const sourceParent = sourceView
			.getItem()
			.getParent()
			.getParent()
			.getParent();

		if (sourceParent instanceof OutboxContainer) {
			return sourceParent;
		}

		return undefined;
	}

	onDropShape(controller, title, sourceView, event, viewer) {
		const item = controller.getModel();
		const selection = sourceView.getSelectedItem();
		const treeItems = sourceView.getItem().getSubTreeForItem(selection);
		treeItems.unshift(selection);
		const cmd = new JSG.CompoundCommand();
		let guessSerie;
		let chartTitle;

		if (treeItems.length > 1 && treeItems[1].level > treeItems[0].level) {
			chartTitle = treeItems[0].key;
		}

		for (let i = treeItems.length - 1; i >= 0; i -= 1) {
			const treeItem = treeItems[i];
			if (treeItem.type < 3 || treeItem.type > 5) {
				JSG.Arrays.remove(treeItems, treeItem);
			}
		}

		treeItems.forEach((treeItem, index) => {
			if (treeItem && treeItem.type >= 3 && treeItem.type <= 5) {
				const label = treeItem.key || '';
				const itemPath = sourceView.getItem().getItemPathDot(treeItem);
				if (item instanceof TextNode) {
					const expr = new Expression(0, `INBOXDATA.${itemPath}`);
					cmd.add(SheetCommandFactory.create('command.SetTextCommand', item, item.getText(), expr));
				} else if (item instanceof SheetCheckboxNode) {
					const expr = new Expression(0, `INBOXDATA.${itemPath}`);
					cmd.add(new SetAttributeAtPathCommand(item, 'value', expr));
					cmd.add(new SetAttributeAtPathCommand(item, 'title', new StringExpression(label)));
				} else if ((item instanceof SheetSliderNode) || (item instanceof SheetKnobNode)) {
					const expr = new NumberExpression(0, `INBOXDATA.${itemPath}`);
					cmd.add(new SetAttributeAtPathCommand(item, 'value', expr));
					cmd.add(new SetAttributeAtPathCommand(item, 'title', new StringExpression(label)));
				} else if (item.getParent() instanceof JSG.LayoutCell) {
					const node = new JSG.TextNode('Title');
					const tf = node.getTextFormat();
					tf.setHorizontalAlignment(JSG.TextFormatAttributes.TextAlignment.LEFT);
					tf.setVerticalAlignment(JSG.TextFormatAttributes.VerticalTextAlignment.TOP);
					tf.setRichText(false);
					tf.setFontSize(10);
					const f = node.getFormat();
					f.setLineStyle(JSG.FormatAttributes.LineStyle.SOLID);
					f.setLineCorner(75);
					node.setText(new Expression(0, `INBOXDATA.${itemPath}`));
					node.associate(false);
					node.setHeight(1000);
					node.getItemAttributes().setLabel(label);
					cmd.add(new JSG.AddItemCommand(node, item));
				}
			}
		});

		if (cmd) {
			viewer.getInteractionHandler().execute(cmd);
			if (guessSerie) {
				const cmdSeries = item.prepareCommand('series');
				item.guessMap(guessSerie);
				guessSerie.map.mapData = undefined;
				guessSerie.map.requesting = undefined;
				item.finishCommand(cmdSeries, 'series');
				viewer.getInteractionHandler().execute(cmdSeries);
			}
		}
	}

	/**
	 * Drop operation to execute. Here a formula is created to fetch data from the json tree.
	 *
	 * @param feedback Feedback for drag operation.
	 * @param {String} title Text of source item
	 * @param sourceView View of source item
	 * @param event MouseEvent
	 * @param viewer GraphViewer
	 */
	onDrop(feedback, title, sourceView, event, viewer) {
		if (sourceView === undefined) {
			return;
		}

		const selection = sourceView.getSelectedItem();
		if (selection === undefined || this.isMessageBox(sourceView, event)) {
			return;
		}

		const inBox = this.isInbox(sourceView, event);
		if (inBox === undefined) {
			return;
		}

		const vertical = event.isPressed(ClientEvent.KeyType.CTRL);
		const altKey = event.isPressed(ClientEvent.KeyType.ALT);
		const range = new CellRange(this.getItem(), feedback._cell.x, feedback._cell.y);
		let targetRange;

		if (altKey) {
			targetRange = new CellRange(
				this.getItem(),
				feedback._cell.x - (vertical ? 0 : 1),
				feedback._cell.y - (vertical ? 1 : 0)
			);
		} else {
			targetRange = new CellRange(
				this.getItem(),
				feedback._cell.x + (vertical ? 0 : 1),
				feedback._cell.y + (vertical ? 1 : 0)
			);
		}

		let formula;
		const key = feedback._key;

		range.shiftToSheet();
		targetRange.shiftToSheet();

		const treeItems = sourceView.getItem().getSubTreeForItem(selection);
		treeItems.unshift(selection);

		let skipDepth;
		const rows = key ? treeItems.length : 1;
		const targetRangeMemory = [];
		const cellData = [];
		const outbox = this.getOutbox(sourceView);

		for (let i = 0; i < rows; i += 1) {
			if (skipDepth !== undefined && skipDepth === treeItems[i].depth) {
				while (treeItems[i] && treeItems[i].depth >= skipDepth) {
					i += 1;
					if (treeItems[i] === undefined) {
						return;
					}
				}
				skipDepth = undefined;
			}
			const itemPath = sourceView.getItem().getItemPath(treeItems[i]);
			const path = TreeItemsNode.splitPath(itemPath);

			if (inBox && !altKey) {
				const sourceSheet = this.getSourceProcessSheet(sourceView);
				let sheetName = '';
				if (sourceSheet.getId() !== this.getItem().getId()) {
					sheetName = `"${sourceSheet.getName().getValue()}"`;
				}
				if (itemPath.startsWith('[Metadata]')) {
					formula = `READ(INBOXMETADATA(${sheetName},`;
				} else {
					formula = `READ(INBOXDATA(${sheetName},`;
				}
			} else {
				let name = 'Message';
				if (outbox !== undefined) {
					let sel = outbox.getMessageListItems().getSelectedItem();
					if (!sel) {
						sel = sourceView._findSelectedItemByLevel(0);
					}
					if (sel && sel.id) {
						name = sel.id;
					}
				}
				const pathfn = itemPath.startsWith('[Metadata]') ? 'OUTBOXMETADATA' : 'OUTBOXDATA';
				const mainfn = altKey ? 'WRITE' : 'READ';
				formula = `${mainfn}(${pathfn}("${name}"`;
			}

			const activeItem = sourceView
				.getItem()
				.getTreeItemAttributes()
				.getActiveElement()
				.getValue();
			let activePath;

			if (activeItem && activeItem.length && itemPath.startsWith(`${activeItem}`)) {
				activePath = TreeItemsNode.splitPath(activeItem);
			}

			let pos = inBox ? 1 : 0;

			if (inBox) {
				if (activePath && activePath.length !== path.length) {
					for (; pos < activePath.length; pos += 1) {
						if (activePath[pos] !== path[pos]) {
							break;
						}
					}
					if (pos === activePath.length) {
						formula += ',';
						pos += 1;
						if (skipDepth === undefined) {
							skipDepth = treeItems[i].depth;
						}
					} else {
						pos = 0;
					}
				} else {
					pos = 1;
				}
			} else {
				pos = 1;
			}

			if (path.length !== 1 || !inBox) {
				for (; pos < path.length; pos += 1) {
					formula += ',';
					let elem;
					if (treeItems[i].parent && pos < path.length - 1) {
						if (targetRangeMemory[pos]) {
							elem = targetRangeMemory[pos];
							formula += `${elem}`;
						}
					}
					if (elem === undefined) {
						elem = path[pos];
						formula += `"${elem}"`;
					}
				}
			}

			formula += '),';

			switch (treeItems[i].type) {
				case TreeItemsNode.DataType.OBJECT:
					// DL-4107: for READ add cell reference
					formula += !altKey && rows === 1 ? targetRange.toString() : '';
					formula += ',"Dictionary"';
					break;
				case TreeItemsNode.DataType.ARRAY:
					// DL-4107: for READ add cell reference
					formula += !altKey && rows === 1 ? targetRange.toString() : '';
					formula += ',"Array"';
					break;
				case TreeItemsNode.DataType.STRING:
					formula += targetRange.toString();
					formula += ',"String"';
					break;
				case TreeItemsNode.DataType.NUMBER:
					formula += targetRange.toString();
					formula += ',"Number"';
					break;
				case TreeItemsNode.DataType.BOOLEAN:
					formula += targetRange.toString();
					formula += ',"Bool"';
					break;
				default:
					break;
			}
			// DL-3590: always set last parameter of READ formula on DnD
			formula += formula.startsWith('READ') ? ',,TRUE)' : ')';

			let cell = {};
			cell.reference = range.toString();
			cell.value = undefined; // DL-2214 if cell value is undefined formula result is used
			cell.formula = formula;
			cellData.push(cell);

			targetRangeMemory[treeItems[i].depth] = range.toString();

			if (altKey && treeItems[i].value !== undefined) {
				const data = this.getItem().getDataProvider();

				const valueRange = range.copy();
				if (vertical) {
					valueRange._y1 -= 1;
					valueRange._y2 -= 1;
				} else {
					valueRange._x1 -= 1;
					valueRange._x2 -= 1;
				}
				const valueCell = data.getRC(
					valueRange._x1 -
						this.getItem()
							.getColumns()
							.getInitialSection(),
					valueRange._y1 -
						this.getItem()
							.getRows()
							.getInitialSection()
				);
				if (valueCell === undefined || valueCell.getValue() === undefined) {
					// const item = this.getItem();
					cell = {};
					cell.reference = valueRange.toString();
					cell.value = treeItems[i].value;
					cellData.push(cell);
				}
			}

			if (vertical) {
				range._x1 += 1;
				range._x2 += 1;
				targetRange._x1 += 1;
				targetRange._x2 += 1;
			} else {
				range._y1 += 1;
				range._y2 += 1;
				targetRange._y1 += 1;
				targetRange._y2 += 1;
			}
		}
		if (cellData.length) {
			viewer
				.getInteractionHandler()
				.execute(
					SheetCommandFactory.create('command.SetCellsCommand', this.getItem(), cellData, true)
				);
		}
	}

	static get SHEET_DROP_FROM_OUTBOX() {
		return SHEET_DROP_FROM_OUTBOX;
	}
}
